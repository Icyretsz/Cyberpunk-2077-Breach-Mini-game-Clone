<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Cyberpunk 2077 Breaching Mini game</title>
    <link rel="stylesheet" href="./style.css"/>
</head>

<body>
<div class="game-section">
    <div class="section-left">
        <div class="time-container">
            <div class="time-remaining">BREACH TIME REMAINING</div>
            <div class="timer">5:00</div>
        </div>
        <div class="matrix-main">
            <div class="matrix-container"></div>
        </div>
    </div>

    <div class="section-right">
        <div class="buffer">BUFFER</div>
        <div class="buffer-container"></div>
        <div class="sequence-main">
            <div class="sequence">SEQUENCE REQUIRED TO UPLOAD</div>
            <div class="sequence-container">
                <div class="sequence-1"></div>
                <div class="sequence-2"></div>
                <div class="sequence-3"></div>
            </div>
        </div>
    </div>

    <button id="startBtn">START</button>
    <button id="resetBtn">RESET</button>
    <div class="results-container"></div>
</div>
<div class="generate-principles">Generate principles:
    <p>1. The buffer slots will equal to total of hexadecimals generated.</p>
    <p>2. The first sequence: 2 to 3 hexes.</p>
    <p>3. The second sequence: 2 to 4 hexes.</p>
    <p>4. The third sequence: 3 to 4 hexes.</p>
    <p>5. The matrix size (n: row, m: column) will have n = m, n and m will be determined by summing the
        first and second sequence.</p>
    <p>6. The matrix will contain only the hexadecimals generated (all the hexadecimals in 3 sequences).</p>
</div>

</body>

<script>
    const startBTN = document.querySelector("#startBtn");
    const resetBTN = document.querySelector("#resetBtn");
    const matrixContainer = document.querySelector(".matrix-container");
    const bufferContainer = document.querySelector(".buffer-container");
    const sequenceContainer = document.querySelector(".sequence-container");
    const sequence1 = document.querySelector(".sequence-1");
    const sequence2 = document.querySelector(".sequence-2");
    const sequence3 = document.querySelector(".sequence-3");
    const resultContainer = document.querySelector(".results-container")


    function randomTwoDigitHexArray(count) {
        const hexChars = "0123456789ABCDEF";
        let hexArray = [];

        for (let j = 0; j < count; j++) {
            let hex = "";
            for (let i = 0; i < 2; i++) {
                hex += hexChars[Math.floor(Math.random() * 16)];
            }
            hexArray.push(hex);
        }
        return hexArray;
    }

    function firstSequenceFill() {
        let size = Math.floor(Math.random() * 2) + 2;
        let hexArray = randomTwoDigitHexArray(size);
        for (let i = 0; i < hexArray.length; i++) {
            let hex = document.createElement('p');
            sequence1.appendChild(hex);
            hex.textContent = `${hexArray[i]}`;
        }
        return hexArray;
    }

    function secondSequenceFill() {
        let size = Math.floor(Math.random() * 3) + 2;
        let hexArray = randomTwoDigitHexArray(size);
        for (let i = 0; i < hexArray.length; i++) {
            let hex = document.createElement('p');
            sequence2.appendChild(hex);
            hex.textContent = `${hexArray[i]}`;
        }
        return hexArray;
    }

    function thirdSequenceFill() {
        let size = Math.floor(Math.random() * 2) + 3;
        let hexArray = randomTwoDigitHexArray(size);
        for (let i = 0; i < hexArray.length; i++) {
            let hex = document.createElement('p');
            sequence3.appendChild(hex);
            hex.textContent = `${hexArray[i]}`;
        }
        return hexArray;
    }

    let bufferSlots = [];
    function createBufferSlot() {
        let sequence1Array = firstSequenceFill();
        let sequence2Array = secondSequenceFill();
        let sequence3Array = thirdSequenceFill();
        let bufferSize = sequence1Array.length + sequence2Array.length + sequence3Array.length;
        for (let i = 0; i < bufferSize; i++) {
            const buffer = document.createElement('p');
            bufferContainer.appendChild(buffer);
            buffer.className = `bufferBTN-${i}`;
            bufferSlots.push(buffer);
        }
    }

    /*function arrangeSequence() {
        const sequences = [sequence1, sequence2, sequence3];
        sequences.sort((a, b) => a.querySelectorAll("p").length - b.querySelectorAll("p").length);
        sequences.forEach(seq => sequenceContainer.appendChild(seq));
    }*/

    function getHexInSequenceArray(sequence) {
        let hexes = [];
        sequence.querySelectorAll('p').forEach(p => {
            hexes.push(p);
        });
        return hexes;
    }

    function getAllHexInSequencesArray() {
        let hexArray = [];
        hexArray = hexArray.concat(getHexInSequenceArray(sequence1));
        hexArray = hexArray.concat(getHexInSequenceArray(sequence2));
        hexArray = hexArray.concat(getHexInSequenceArray(sequence3));
        return hexArray;
    }

    function getMatrixSize() {
        let sequenceLengths = [sequence1.querySelectorAll('p').length
            , sequence2.querySelectorAll('p').length
            , sequence3.querySelectorAll('p').length];
        sequenceLengths.sort((a, b) => a - b);
        return sequenceLengths[0] + sequenceLengths[1];
    }

    let matrixSize = 0;
    let hexInMatrix = [];
    let hexClickedBox = [];
    let bufferIndexCount = 0;

    function coreMatrixMechanic() {
        //Creating the matrix
        let hexArray = getAllHexInSequencesArray();
        matrixSize = getMatrixSize();
        for (let i = 0; i < matrixSize; i++) {
            let row = document.createElement('div');
            matrixContainer.appendChild(row);
            let matrixRow = [];
            for (let j = 0; j < matrixSize; j++) {
                let rowContent = document.createElement('button');
                row.appendChild(rowContent);
                let index = Math.floor(Math.random() * hexArray.length)
                rowContent.textContent = `${hexArray[index].textContent}`;
                rowContent.className = `matrixBTN-${i}-${j}`;
                //Handle when buttons are clicked
                rowContent.addEventListener('click', () => {
                    bufferSlots[bufferIndexCount].textContent = rowContent.textContent;
                    hexClickedBox.push(rowContent);
                    if (bufferIndexCount === 0 || bufferIndexCount % 2 === 0) {
                        blockAllBTN();
                        for (let d = 0; d < matrixSize; d++) {
                            if (d === i) continue;
                            hexInMatrix[d][j].disabled = false;
                        }
                    } else if (bufferIndexCount === 1 || bufferIndexCount % 2 !== 0) {
                        blockAllBTN();
                        for (let e = 0; e < matrixSize; e++) {
                            if (e === j) continue;
                            hexInMatrix[i][e].disabled = false;
                        }
                    }
                    compareClickToSequence1();
                    compareClickToSequence2();
                    compareClickToSequence3();
                    bufferIndexCount++;
                    if (bufferIndexCount === bufferSlots.length) maxBufferExceeded();
                });
                matrixRow.push(rowContent);
            }
            hexInMatrix.push(matrixRow);
        }
        disableBTNExceptFirstRow();
    }

    let sequence1IndexTrack = 0;

    function compareClickToSequence1() {
        let hexInSequence1Array = getHexInSequenceArray(sequence1);
        if (sequence1IndexTrack < hexInSequence1Array.length) {
            if (hexClickedBox[bufferIndexCount].textContent === hexInSequence1Array[sequence1IndexTrack].textContent) {
                hexInSequence1Array[sequence1IndexTrack].className = `correctly-chosen-hex`;
                sequence1IndexTrack++;
            }
        } else if (sequence1IndexTrack >= 3) return;
    }

    let sequence2IndexTrack = 0;

    function compareClickToSequence2() {
        let hexInSequence2Array = getHexInSequenceArray(sequence2);
        if (sequence2IndexTrack < hexInSequence2Array.length) {
            if (hexClickedBox[bufferIndexCount].textContent === hexInSequence2Array[sequence2IndexTrack].textContent) {
                hexInSequence2Array[sequence2IndexTrack].className = `correctly-chosen-hex`;
                sequence2IndexTrack++;
            }
        } else if (sequence2IndexTrack >= 4) return;
    }

    let sequence3IndexTrack = 0;

    function compareClickToSequence3() {
        let hexInSequence3Array = getHexInSequenceArray(sequence3);
        if (sequence3IndexTrack < hexInSequence3Array.length) {
            if (hexClickedBox[bufferIndexCount].textContent === hexInSequence3Array[sequence3IndexTrack].textContent) {
                hexInSequence3Array[sequence3IndexTrack].className = `correctly-chosen-hex`;
                sequence3IndexTrack++;
            }
        } else if (sequence3IndexTrack >= 4) return;
    }

    function maxBufferExceeded() {
        let anySequenceCompleted = false;
        alert(`Game Over!`);
        if (sequence1IndexTrack === getHexInSequenceArray(sequence1).length) {
            let result1 = document.createElement('p');
            resultContainer.appendChild(result1);
            result1.textContent = `You have completed sequence 1`;
            anySequenceCompleted = true;
        }
        if (sequence2IndexTrack === getHexInSequenceArray(sequence2).length) {
            let result2 = document.createElement('p');
            resultContainer.appendChild(result2);
            result2.textContent = `You have completed sequence 2`;
            anySequenceCompleted = true;
        }
        if (sequence3IndexTrack === getHexInSequenceArray(sequence3).length) {
            let result3 = document.createElement('p');
            resultContainer.appendChild(result3);
            result3.textContent = `You have completed sequence 3`;
            anySequenceCompleted = true;
        }

        if (!anySequenceCompleted) {
            alert(`Failed!`);
        }
    }

    function disableBTNExceptFirstRow() {
        for (let i = 0; i < matrixSize; i++) {
            for (let j = 0; j < matrixSize; j++) {
                hexInMatrix[i][j].addEventListener('mouseover', () => {
                    if (bufferIndexCount === 0) {
                        for (let k = 1; k < matrixSize; k++) {
                            for (let a = 0; a < matrixSize; a++) {
                                hexInMatrix[k][a].disabled = true;
                            }
                        }
                    }
                })
                hexInMatrix[i][j].addEventListener('mouseout', () => {
                    if (bufferIndexCount === 0) {
                        for (let k = 0; k < matrixSize; k++) {
                            for (let a = 0; a < matrixSize; a++) {
                                hexInMatrix[k][a].disabled = false;
                            }
                        }
                    }
                });
            }
        }
    }

    function blockAllBTN() {
        for (let b = 0; b < matrixSize; b++) {
            for (let c = 0; c < matrixSize; c++) {
                hexInMatrix[b][c].disabled = true;
            }
        }
    }

    let startedFlag = 0;

    startBTN.addEventListener("click", () => {
        if (startedFlag === 0) {
            createBufferSlot();
            startedFlag = 1;
            //arrangeSequence();
            coreMatrixMechanic();
        } else {
            return;
        }
    });

    resetBTN.addEventListener("click", () => {
        const hexes = sequenceContainer.querySelectorAll("p");
        const buffers = bufferContainer.querySelectorAll("p");
        const matrixP = matrixContainer.querySelectorAll("p");
        const matrixDiv = matrixContainer.querySelectorAll("div");
        const results = resultContainer.querySelectorAll("p");
        hexes.forEach(hex => hex.remove());
        buffers.forEach(buffer => buffer.remove());
        matrixDiv.forEach(div => div.remove());
        matrixP.forEach(p => p.remove());
        results.forEach(p => p.remove());
        startedFlag = 0;
        bufferSlots = [];
        hexInMatrix = [];
        bufferIndexCount = 0;
        hexClickedBox = [];
        sequence1IndexTrack = 0;
        sequence2IndexTrack = 0;
        sequence3IndexTrack = 0;
    });
</script>

</html>